
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

expr = { and_expr ~ (^"OR" ~ and_expr)* }
and_expr = { term ~ (^"AND" ~ term)* }
term = _{ binary_op | atom }

binary_op = { atom ~ op ~ atom }
op = { "=" }

atom = _{ bool | float | int | prop_lookup | func_call | string | id | list | "(" ~ expr ~ ")" }

id = @{ ( ASCII_ALPHA | "_" | "-" )+ }

prop_lookup = { id ~ ("." ~ id)+ }

func_call = { id ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

string = ${
  "\"" ~ dblq_str_inner ~ "\"" |
  "'" ~ singleq_str_inner ~ "'" }
dblq_str_inner = @{ dbldq_char* }
dbldq_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}
singleq_str_inner = @{ singleq_char* }
singleq_char = {
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}

bool = _{ lit_true | lit_false }
lit_true = { ^"TRUE" }
lit_false = { ^"FALSE" }

int = ${
    "-"? ~ ( "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* )
}

float = ${
   "-"? ~ ( "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ) ~ "." ~ ASCII_DIGIT*
}

map = {
  "{" ~ "}" |
  "{" ~ map_pair ~ ("," ~ map_pair)* ~ "}"
}
map_pair = { id ~ ":" ~ expr }

list = {
  "[" ~ "]" |
  "[" ~ expr ~ ("," ~ expr)* ~ "]"
}

// Multiple labels are supported for CREATE but not yet for MATCH
node = { "(" ~ id? ~ ( ":" ~ label )* ~ map? ~ ")" }
label = { id }

rel = { left_arrow? ~ "-" ~ ( "[" ~ id? ~ ( ":" ~ rel_type )? ~ map? ~ "]" )? ~ "-" ~ right_arrow? }
rel_type = { id }
left_arrow = { "<" }
right_arrow = { ">" }

pattern = { node  ~ ( rel ~ node )* }

projection = { expr ~ ("AS" ~ id)? }
projections = { projection ~ ( "," ~ projection )* }

where_clause = { "WHERE" ~ expr }

create_stmt = { "CREATE" ~ pattern }
match_stmt = { "MATCH" ~ pattern ~ where_clause? }
unwind_stmt = { "UNWIND" ~ expr ~ "AS" ~ id }

with_stmt = { "WITH" ~ projections }
return_stmt = { "RETURN" ~ projections }

reading_clause = _{ match_stmt | unwind_stmt }
writing_clause = _{ create_stmt }

single_query = _{
  (reading_clause* ~ return_stmt) |
  (reading_clause* ~ writing_clause+ ~ return_stmt?)
}

multi_query = _{
  (reading_clause* ~ writing_clause* ~ with_stmt)* ~ single_query
}

query = { SOI ~ ( single_query | multi_query ) ~ EOI }
